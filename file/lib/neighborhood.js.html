<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">lib/neighborhood.js | Neighborhood-wrtc API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/chat-wane/neighborhood-wrtc.git/" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/lib/neighborhood.js~Neighborhood.html">Neighborhood</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-MultiSet">MultiSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-SortedArray">SortedArray</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-EventEmitter">EventEmitter</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">lib/neighborhood.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">&apos;use strict&apos;;

const EventEmitter = require(&apos;events&apos;);
const _ = require(&apos;lodash&apos;);
const uuid = require(&apos;uuid/v4&apos;);
const SortedArray = require(&apos;./extended-sorted-array.js&apos;);
const MultiSet = require(&apos;./multiset.js&apos;);
const SimplePeer = require(&apos;simple-peer&apos;);

/**
 * Easy-to-use interface on SimplePeer (npm: simple-peer)
 * @param {object} options the options available to the connections, e.g. timeout before
 * @param {string} options.protocol Protocol to use
 * @param {object} options.webrtc Webrtc options
 * @param {number} options.timeout Time to wait for socket destruction or failed message (time in milliseconds)
 * @param {function} options.encoding Method to customize message sent, default: return JSON.stringify(data);
 * @param {function} options.decoding Method to decode a received message, default: return JSON.parse(data);
 * @param {boolean} options.verbose Print log message: default false
 */
class Neighborhood extends EventEmitter {
	constructor (options) {
		super();
    // #1 save options
    this.options = {
      protocol: &apos;default&apos;,
      webrtc: {
        iceServers: [],
        trickle: false,
        initiator: false
      },
      config: {},
      trickle: false,
      timeout: 2 * 60 * 1000,
      encoding: (d) =&gt; {
        return JSON.stringify(d);
      },
      decoding: (d) =&gt; {
        return JSON.parse(d);
      },
      verbose: false
    };
    this.options = _.merge(this.options, options);
    // Override config to match webrtc options
    this.options.config = this.options.webrtc;

    this.protocol = this.options.protocol + &apos;-neighborhood-wrtc&apos;;

		this.encoding = this.options.encoding;
		this.decoding = this.options.decoding;
		this.ID = uuid();

		if(options &amp;&amp; options.verbose) {
			this.verbose = options.verbose;
		}

    /*!
     * \brief compare the id of entries in tables
     */
    this.Comparator = (a, b) =&gt; {
        var first = a.id || a;
        var second = b.id || b;
        if (first &lt; second){ return -1; };
        if (first &gt; second){ return  1; };
        return 0;
    };
    // #2 initialize tables
    this.pending = new SortedArray(this.Comparator); // not finalized yet
    this.living = new MultiSet(this.Comparator); // live and usable
    this.dying = new SortedArray(this.Comparator); // being remove
	}

  /**
   * @private
   */
	MResponse (tid, pid, offer, protocol) {
		return {
			tid: tid,
			pid: pid,
			protocol: protocol,
			type: &apos;MResponse&apos;,
			offer: offer
		};
	}
  /**
   * @private
   */
	MRequest (tid, pid, offer, protocol) {
		return {
			tid: tid,
			pid: pid,
			protocol: protocol,
			type: &apos;MRequest&apos;,
			offer: offer
		};
	}

  /**
   * @private
   */
	log (...args) {
		if(this.verbose) {
			console.log(&apos;[NEIGHBORHOOD] &apos;, args);
		}
	}

  /**
   * Disconnect one of the arc with the identifier in argument. If
   * it was the last arc with such id, the socket is relocated to the dying
   * table. The socket will be destroy after a bit. If there is no argument,
   * disconnect the whole.
   * @param {string|undefined} id Id provided to just disconnect the arc or if undefined disconnect all arcs
   */
  disconnect (id) {
    let result = true;
    if (!id) {
      // #1 disconnect everything
      this.pending.arr.forEach((e) =&gt; {
          e.socket &amp;&amp; e.socket.destroy();
      });
      while (this.living.ms.arr.length &gt; 0) {
          const e = this.living.ms.arr[0];
          e.socket &amp;&amp; e.socket.destroy();
      }
      while (this.dying.arr.length &gt; 0) {
          const e = this.dying.arr[0];
          e.socket &amp;&amp; e.socket.destroy();
      }
    } else {
      // #2 remove one arc
      let entry = this.living.remove(id);
      entry &amp;&amp; this.emit(&apos;disconnect&apos;, entry.id);
      if (entry &amp;&amp; entry.occ &lt;= 0) {
          entry.timeout = setTimeout(function () {
              entry.socket.destroy();
          }, this.options.timeout);
          this.dying.insert(entry);
      }
      result = entry &amp;&amp; true || false;
    }
    return result;
  }

	/**
	 * New method to encode the message as we want
	 * @param  {object} message The message to encode
	 * @return {string|binary} Encoded message
	 */
	encode (message) {
		return this.encoding(message);
	}

	/**
	 * New method to encode the message as we want
	 * @param  {object} message The message to encode
	 * @return {string|binary} Encoded message
	 */
	decode (message) {
		return this.decoding(message);
	}

	/**
	 * Send a message to the socket in argument
	 * @param {string} id the identifier of the socket
	 * @param {object} message the message to send
	 * @return {boolean} true if the message is sent, false otherwise
	 */
	send (id, message) {
		// #1 convert message to string (TODO) check if there is a better way
		let msg = ((message instanceof String) &amp;&amp; message) || this.encode(message);
		// #2 get the socket to use
		let entry = this.get(id);
		let socket = entry &amp;&amp; entry.socket;
		// #3 send
		let result = msg &amp;&amp; socket &amp;&amp; socket.connected &amp;&amp; socket._channel &amp;&amp; (socket._channel.readyState === &apos;open&apos;);
		// result &amp;&amp; socket.send(msg);
		try {
			result &amp;&amp; socket.send(msg);
			// DONT SET RESULT TO TRUE !
		} catch (e) {
			this.log(&apos;[NEIGHBORHOOD:SEND:ERROR] &apos;, new Error(e));
			result = false;
		}
		return result;
	}

	/**
	* creates a new incomming or outgoing connection depending on arguments
	* @param {callback} callbacks the callback function when the stun/ice server returns the
	* offer
	* @param {object} message empty if it must initiate a connection, or the message received
	* if it must answer or finalize one
	* @param {string} protocol the connection is established for a specific protocol
	* @return {string} the id of the socket
	*/
	connection (callbacks, message, protocol) {

		let msg = (callbacks &amp;&amp; callbacks.type &amp;&amp; callbacks) || message;
		let result;

		if (!msg) {
			result = this.initiate(callbacks, protocol);
		} else if (msg.type===&apos;MRequest&apos;) {

			if(message &amp;&amp; message.pid &amp;&amp; this.ID !== message.pid) {
				result = this.accept(msg, callbacks);
				result = this.alreadyExists(msg, callbacks) || result;
			}

		} else if (msg.type===&apos;MResponse&apos;) {
			result = this.finalize(msg);
			result = this.alreadyExists(msg) || result;
		}

		return result &amp;&amp; result.id;
	}

  /**
   * Get the entry corresponding to the id in argument. The entry contains
   * the socket.
   * @param {string} id the identifier of the socket to retrieve
   * @return {object} an entry from tables. It priorizes entries in living, then dying,
   * then pending.
   */
  get(id){
      return this.living.get(id) || this.dying.get(id) || this.pending.get(id);
  }

	/**
	 * @private
	 * Common behavior to initiating and accepting sockets
	 * @param {object} entry the entry in the neighborhood table
	 * @return {void}
	 */
	common (entry) {
		const self = this, socket = entry.socket;

		socket.on(&apos;data&apos;, (message) =&gt; {
			message = self.decode(message);
			self.emit(&apos;receive&apos;, entry.pid, message);
		});
		socket.on(&apos;stream&apos;, (stream) =&gt; {
			self.emit(&apos;stream&apos;, entry.pid, stream);
		});

		socket.on(&apos;error&apos;, err =&gt; {
			self.emit(&apos;error&apos;, new Error(err));
		});
	}

	/**
	 * @private
	 * initiates a connection with another peer -- the id of which is unknown
	 * @param {callback} callbacks the function to call when signaling info are received and
	 * when the connection is ready to be used
	 * @param {string} protocol The protocol
	 * @return {object} entry
	 */
	initiate (callbacks, protocol) {
		const self = this;
		let opts = self.options.config;
		opts.initiator = true;
		let socket = new SimplePeer(opts);
		let entry = {
			id: uuid(),
			socket: socket,
			protocol: protocol,
			successful: false, // not yet
			onOffer: callbacks &amp;&amp; callbacks.onInitiate,
			onReady: callbacks &amp;&amp; callbacks.onReady
		};

		this.pending.insert(entry);
		socket.on(&apos;signal&apos;, (offer) =&gt; {
			entry.onOffer &amp;&amp; entry.onOffer(self.MRequest(entry.id, self.ID, offer, protocol));
		});

		entry.timeout = setTimeout(() =&gt; {
			let e = self.pending.get(entry.id);
			if (e &amp;&amp; !e.successful) {
				self.emit(&apos;fail&apos;, &apos;[FAIL:INITIATE] an error occured during removing the entry&apos;);
			}
			self.pending.remove(entry) &amp;&amp; socket.destroy();
		}, this.options.timeout);
		return entry;
	}


	/**
	 * @private
	 * accept the offer of another peer
	 * @param {object} message the received message containing id and offer
	 * @param {callback} callbacks the function call after receiving the offer and
	 * when the connection is ready
	 * @return {object} Entry
	 */
	accept (message, callbacks) {
		// #1 if already exists, use it


		let prior = this.pending.get(message.tid);
		if (prior) {
			return prior;
		}
		// #2 otherwise, create the socket
		const self = this;
		// let opts=JSON.parse(JSON.stringify(this.options));// quick but ugly copy
		let opts = this.options.config;
		opts.initiator = false;
		let socket = new SimplePeer(opts);
		let entry = {
			id: message.tid,
			pid: message.pid,
			protocol: message.protocol,
			socket: socket,
			successful: false,
			onOffer: callbacks &amp;&amp; callbacks.onAccept,
			onReady: callbacks &amp;&amp; callbacks.onReady
		};

		this.pending.insert(entry);
		socket.on(&apos;signal&apos;, function (offer) {
			entry.onOffer &amp;&amp; entry.onOffer(self.MResponse(entry.id, self.ID, offer, entry.protocol));
		});
		socket.on(&apos;connect&apos;, function () {
			self.get(entry.pid) &amp;&amp; socket.destroy();
			self.pending.remove(entry);
			self.living.insert({
				id: entry.pid,
				socket: entry.socket,
				onReady: entry.onReady,
				onOffer: entry.onOffer
			});


			entry.onReady &amp;&amp; entry.onReady(entry.pid);
			self.emit(&apos;ready&apos;, entry.pid);
			entry.protocol &amp;&amp; self.emit(&apos;ready-&apos;+entry.protocol, entry.pid);

			clearTimeout(entry.timeout);
			entry.timeout = null;
		});
		socket.on(&apos;close&apos;, function () {
			if (self.pending.contains(entry.id)) {
				// #A pending: entry is kept until automatic destruction
				entry.socket = null;
			} else {
				// #B living or dying: clear the tables
				entry.timeout &amp;&amp; clearTimeout(entry.timeout);
				entry.timeout = null;
				let live = self.living.removeAll(entry.pid);
				if (live) {
					for (let i = 0; i &lt; live.occ; ++i) {
						self.emit(&apos;disconnect&apos;, entry.pid);
					}
				}
				self.dying.remove(entry.pid);
			}
		});

		this.common(entry);

		entry.timeout = setTimeout(function () {
			let e = self.pending.get(entry.id);
			if (e &amp;&amp; !e.successful) {
				self.emit(&apos;fail&apos;, &apos;[FAIL:ACCEPT] an error occured during removing the entry&apos;);
			}
			self.pending.remove(entry.id) &amp;&amp; socket.destroy();
		}, this.options.timeout);
		return entry;
	}


	/**
	 * @private
	* finalize the behavior of an initiating socket
	* @param {object} message the received message possibly containing an answer to the
	* proposed offer
	* @return {object} Return prior entry
	*/
	finalize (message) {
		// #1 if it does not exists, stop; or if it exists but already setup
		// return it
		let prior = this.pending.get(message.tid);
		if (!prior || prior.pid) {
			return prior;
		}
		// #2 otherwise set the events correctly
		prior.pid = message.pid;

		let entry = {
			id: message.pid,
			socket: prior.socket,
			protocol: prior.protocol,
			onReady: prior.onReady,
			onOffer: prior.onOffer
		};

		const self = this;
		let socket = entry.socket;
		socket.on(&apos;connect&apos;, function () {

			self.get(entry.id) &amp;&amp; socket.destroy();
			self.pending.remove(prior);
			self.living.insert(entry);
			entry.onReady &amp;&amp; entry.onReady(prior.pid);
			self.emit(&apos;ready&apos;, prior.pid);
			entry.protocol &amp;&amp; self.emit(&apos;ready-&apos;+entry.protocol, prior.pid);
			clearTimeout(prior.timeout);

		});
		socket.on(&apos;close&apos;, function () {
			if (self.pending.contains(message.tid)) {
				self.pending.get(message.tid).socket = null;
			} else {
				prior.timeout &amp;&amp; clearTimeout(prior.timeout);
				prior.timeout = null;
				let live = self.living.removeAll(prior.pid);
				if (live) {
					for (let i = 0; i &lt; live.occ; ++i) {
						self.emit(&apos;disconnect&apos;, prior.pid);
					}
				}
				self.dying.remove(prior.pid);
			}
		});

		this.common(prior);

		return prior;
	}

	/**
	 * @private
	*  the peer id already exists in the tables
	*  @param {object} message The message
	*  @param {callback} callbacks the callbacks
	*  @return {object} alreaydExist
	*/
	alreadyExists (message, callbacks) {
		const self = this;
		let alreadyExists = this.get(message.pid);
		if  (!alreadyExists) {
			// #A does not already exists but pending
			let entry = this.pending.get(message.tid);
			entry &amp;&amp; entry.socket &amp;&amp; message.offer &amp;&amp; entry.socket.signal(message.offer);
		} else {
			// #B already exists and pending
			let toRemove = this.pending.get(message.tid);
			if (toRemove &amp;&amp; toRemove.socket) { // exists but socket still w8in
				if (!alreadyExists.timeout) {
					// #1 already in living socket, add an occurrence
					this.living.insert(message.pid);
					toRemove.successful = true;
				} else {
					// #2 was dying, resurect the socket
					this.dying.remove(alreadyExists);
					clearTimeout(alreadyExists.timeout);
					alreadyExists.timeout = null;
					this.living.insert(alreadyExists);
					toRemove.successful = true;
				}
				toRemove.socket.destroy();
				// #C standard on accept function if it exists in arg
				message.offer &amp;&amp; callbacks &amp;&amp; callbacks.onAccept &amp;&amp; callbacks.onAccept(self.MResponse(message.tid, this.ID,	null,	message.protocol));

				(callbacks &amp;&amp;	callbacks.onReady &amp;&amp; callbacks.onReady(alreadyExists.id)) ||	(toRemove &amp;&amp; 	toRemove.onReady &amp;&amp;	toRemove.onReady(alreadyExists.id));
				this.emit(&apos;ready&apos;, alreadyExists.id);
				message.protocol &amp;&amp; this.emit(&apos;ready-&apos;+message.protocol, alreadyExists.id);
			}
		}
		return alreadyExists;
	}

}


module.exports = Neighborhood;
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
